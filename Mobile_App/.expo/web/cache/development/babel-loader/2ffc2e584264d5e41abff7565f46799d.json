{"ast":null,"code":"var reTrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g;\n\nvar EventSource = function EventSource(url, options) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      lastIndexProcessed = 0,\n      eventType;\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.OPTIONS = options;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function pollAgain(interval) {\n    eventsource._pollTimer = setTimeout(function () {\n      poll.call(eventsource);\n    }, interval);\n  }\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n      var xhr = new XMLHttpRequest();\n      xhr.open(eventsource.OPTIONS.method || 'GET', eventsource.URL, true);\n\n      if (eventsource.OPTIONS && eventsource.OPTIONS.headers) {\n        Object.keys(eventsource.OPTIONS.headers).forEach(function (key) {\n          xhr.setRequestHeader(key, eventsource.OPTIONS.headers[key]);\n        });\n      }\n\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      lastIndexProcessed = 0;\n      xhr.timeout = this.OPTIONS && this.OPTIONS.timeout !== undefined ? this.OPTIONS.timeout : 50000;\n\n      xhr.onreadystatechange = function () {\n        if (this.readyState == 3 || this.readyState == 4 && this.status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', {\n              type: 'open'\n            });\n          }\n\n          var responseText = '';\n\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(lastIndexProcessed).split('\\n'),\n              data = [],\n              i = 0,\n              retry = 0,\n              line = '';\n          lastIndexProcessed = responseText.lastIndexOf('\\n\\n') + 2;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('retry') == 0) {\n              retry = parseInt(line.replace(/retry:?\\s*/, ''));\n\n              if (!isNaN(retry)) {\n                interval = retry;\n              }\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType || 'message', event);\n                data = [];\n                eventType = undefined;\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(interval);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            pollAgain(interval);\n          } else if (this.readyState == 0) {\n            pollAgain(interval);\n          }\n        }\n      };\n\n      xhr.onerror = function (e) {\n        eventsource.readyState = eventsource.CONNECTING;\n        eventsource.dispatchEvent('error', {\n          type: 'error',\n          message: this.responseText\n        });\n      };\n\n      if (eventsource.OPTIONS.body) {\n        xhr.send(eventsource.OPTIONS.body);\n      } else {\n        xhr.send();\n      }\n\n      if (xhr.timeout > 0) {\n        setTimeout(function () {\n          if (true || xhr.readyState == 3) xhr.abort();\n        }, xhr.timeout);\n      }\n\n      eventsource._xhr = xhr;\n    } catch (e) {\n      eventsource.dispatchEvent('error', {\n        type: 'error',\n        data: e.message\n      });\n    }\n  }\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function close() {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function dispatchEvent(type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function addEventListener(type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function removeEventListener(type, handler) {\n    var handlers = this['_' + type + 'Handlers'];\n\n    if (!handlers) {\n      return;\n    }\n\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n        break;\n      }\n    }\n  },\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function MessageEvent(data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};\nexport default EventSource;","map":{"version":3,"sources":["/media/allen/SIMBAD/Flaskprojects/teklife/Teklife/node_modules/react-native-event-source/EventSource.js"],"names":["reTrim","EventSource","url","options","eventsource","interval","lastEventId","lastIndexProcessed","eventType","SyntaxError","URL","OPTIONS","readyState","CONNECTING","_pollTimer","_xhr","pollAgain","setTimeout","poll","call","CLOSED","xhr","XMLHttpRequest","open","method","headers","Object","keys","forEach","key","setRequestHeader","timeout","undefined","onreadystatechange","status","OPEN","dispatchEvent","type","responseText","e","parts","substr","split","data","i","retry","line","lastIndexOf","length","replace","indexOf","parseInt","isNaN","push","event","MessageEvent","join","onerror","message","body","send","abort","prototype","close","clearInterval","handlers","addEventListener","handler","removeEventListener","splice","onmessage","onopen","origin"],"mappings":"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","sourcesContent":["// EventSource.js\n// Original implementation from\n// https://github.com/remy/polyfills/blob/master/EventSource.js\n//\n// Copyright (c) 2010 Remy Sharp, http://remysharp.com\n\nvar reTrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g;\n\nvar EventSource = function(url, options) {\n  var eventsource = this,\n    interval = 500, // polling interval\n    lastEventId = null,\n    lastIndexProcessed = 0,\n    eventType;\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.OPTIONS = options;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function pollAgain(interval) {\n    eventsource._pollTimer = setTimeout(function() {\n      poll.call(eventsource);\n    }, interval);\n  }\n\n  function poll() {\n    try {\n      // force hiding of the error message... insane?\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      // NOTE: IE7 and upwards support\n      var xhr = new XMLHttpRequest();\n      xhr.open(eventsource.OPTIONS.method || 'GET', eventsource.URL, true);\n      if (eventsource.OPTIONS && eventsource.OPTIONS.headers) {\n        Object.keys(eventsource.OPTIONS.headers).forEach(key => {\n          xhr.setRequestHeader(key, eventsource.OPTIONS.headers[key]);\n        });\n      }\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      // we must make use of this on the server side if we're working with Android - because they don't trigger\n      // readychange until the server connection is closed\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null)\n        xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      lastIndexProcessed = 0;\n\n      xhr.timeout =\n        this.OPTIONS && this.OPTIONS.timeout !== undefined\n          ? this.OPTIONS.timeout\n          : 50000;\n\n      xhr.onreadystatechange = function() {\n        if (\n          this.readyState == 3 ||\n          (this.readyState == 4 && this.status == 200)\n        ) {\n          // on success\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          // process this.responseText\n          var parts = responseText.substr(lastIndexProcessed).split('\\n'),\n            data = [],\n            i = 0,\n            retry = 0,\n            line = '';\n          lastIndexProcessed = responseText.lastIndexOf('\\n\\n') + 2;\n\n          // TODO handle 'event' (for buffer name), retry\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('retry') == 0) {\n              retry = parseInt(line.replace(/retry:?\\s*/, ''));\n              if (!isNaN(retry)) {\n                interval = retry;\n              }\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              // this resets the id\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(\n                  data.join('\\n'),\n                  eventsource.url,\n                  lastEventId,\n                );\n                eventsource.dispatchEvent(eventType || 'message', event);\n                data = [];\n                eventType = undefined;\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(interval);\n\n          // don't need to poll again, because we're long-loading\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            // and some other status\n            pollAgain(interval);\n          } else if (this.readyState == 0) {\n            // likely aborted\n            pollAgain(interval);\n          }\n        }\n      };\n\n      xhr.onerror = function(e) {\n        // dispatch error\n        eventsource.readyState = eventsource.CONNECTING;\n\n        eventsource.dispatchEvent('error', {\n          type: 'error',\n          message: this.responseText,\n        });\n      };\n\n      if (eventsource.OPTIONS.body) {\n        xhr.send(eventsource.OPTIONS.body);\n      } else {\n        xhr.send();\n      }\n\n      if (xhr.timeout > 0) {\n        setTimeout(function() {\n          if (true || xhr.readyState == 3) xhr.abort();\n        }, xhr.timeout);\n      }\n\n      eventsource._xhr = xhr;\n    } catch (e) {\n      // in an attempt to silence the errors\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message }); // ???\n    }\n  }\n\n  poll(); // init now\n};\n\nEventSource.prototype = {\n  close: function() {\n    // closes the connection - disabling the polling\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function(type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function(type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function(type, handler) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (!handlers) {\n      return;\n    }\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n        break;\n      }\n    }\n  },\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: '',\n};\n\nvar MessageEvent = function(data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: '',\n};\n\nexport default EventSource;\n"]},"metadata":{},"sourceType":"module"}